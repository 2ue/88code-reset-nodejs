# 88code 自动重置工具 - 完整逻辑文档

## 📋 目录

1. [核心策略逻辑](#核心策略逻辑)
2. [完整执行流程](#完整执行流程)
3. [6层过滤检查](#6层过滤检查)
4. [延迟重置逻辑](#延迟重置逻辑)
5. [场景分析](#场景分析)
6. [决策树](#决策树)
7. [状态机](#状态机)

---

## 🎯 核心策略逻辑

### 88code 两次重置制度

**官方规则：**
1. 每天有2次重置机会（resetTimes: 2 → 1 → 0）
2. 两次重置至少间隔5小时
3. 每天00:00系统刷新resetTimes为2
4. 额度可以遗留到第二天（不清零）

### 无脑重置策略

**核心原则：** 确保每天用完2次重置机会，最大化可用额度

#### 18:55 首次重置

```javascript
if (resetTimes == 2) {
    ✅ 无脑重置
    理由：
    - resetTimes=2 说明今天还没重置过
    - 如果不重置，23:55只能用1次
    - 会浪费1次重置机会
} else if (resetTimes < 2) {
    ⏭️ 跳过
    理由：
    - resetTimes<2 说明用户已手动重置
    - 保留给23:55使用
    - 尊重用户的灵活性
}
```

#### 23:56 二次重置（带延迟支持）

```javascript
if (resetTimes >= 1) {
    if (冷却已过) {
        ✅ 直接重置
    } else {
        // 还在冷却中
        if (冷却结束时间 <= 23:59:49) {
            ⏰ 创建延迟定时器
            📅 在冷却结束时自动重置
        } else {
            ❌ 冷却会跨天，放弃
            💡 避免占用次日的重置次数
        }
    }
} else {
    ⏭️ 跳过
    理由：resetTimes=0，今天次数已用完
}
```

---

## 🔄 完整执行流程

### 启动流程

```
┌─────────────────────────────────────┐
│       npm start / node src/index.js  │
└─────────────────────────────────────┘
                  │
                  ↓
┌─────────────────────────────────────┐
│   main() 函数                        │
│   1. 打印欢迎信息                    │
│   2. 检查测试模式                    │
│   3. 初始化服务                      │
│   4. 启动调度器                      │
└─────────────────────────────────────┘
                  │
                  ↓
┌─────────────────────────────────────┐
│   测试模式？(--mode=test)            │
├─ Yes → runTest()                     │
│        - 测试每个API Key              │
│        - 显示订阅信息                 │
│        - 显示余额和resetTimes         │
└─ No  → 跳过                          │
                  │
                  ↓
┌─────────────────────────────────────┐
│   初始化服务                          │
│   - 为每个API Key创建APIClient        │
│   - 为每个Client创建ResetService      │
│   - 包装成统一接口                    │
└─────────────────────────────────────┘
                  │
                  ↓
┌─────────────────────────────────────┐
│   启动调度器 Scheduler.start()        │
│   - 注册18:55首次重置任务             │
│   - 注册23:56二次重置任务             │
│   - 显示下次执行时间                  │
└─────────────────────────────────────┘
                  │
                  ↓
┌─────────────────────────────────────┐
│   服务运行中...                       │
│   等待定时任务触发                    │
└─────────────────────────────────────┘
```

---

### 定时任务执行流程

```
┌─────────────────────────────────────┐
│   Cron 触发 (18:55 或 23:56)          │
└─────────────────────────────────────┘
                  │
                  ↓
┌─────────────────────────────────────┐
│   Scheduler.executeWithLock()        │
│   1. 尝试获取任务锁                   │
│   2. 如果锁已被占用，跳过             │
│   3. 如果获取成功，执行任务           │
└─────────────────────────────────────┘
                  │
                  ↓
┌─────────────────────────────────────┐
│   ResetService.executeReset(type)    │
│   核心业务逻辑                        │
└─────────────────────────────────────┘
                  │
                  ↓
         ┌────────┴────────┐
         ↓                 ↓
    [第1步]            [第2步]
  获取订阅列表        过滤订阅
         │                 │
         └────────┬────────┘
                  ↓
            [第3步]
          逐个处理订阅
                  │
                  ↓
            [第4步]
          汇总结果统计
```

---

### 详细执行步骤

#### 第1步：获取订阅列表

```
APIClient.getSubscriptions()
    ↓
┌─────────────────────────────────────┐
│   RateLimiter.waitForToken()         │
│   - 检查令牌桶                        │
│   - 如果无令牌，等待补充              │
└─────────────────────────────────────┘
    ↓
┌─────────────────────────────────────┐
│   发送HTTP请求                        │
│   POST /api/subscription             │
│   Headers: { Authorization: API_KEY }│
└─────────────────────────────────────┘
    ↓
┌─────────────────────────────────────┐
│   RetryHelper.withRetry()            │
│   - 如果失败，重试最多3次             │
│   - 指数退避: 1s, 2s, 4s             │
└─────────────────────────────────────┘
    ↓
返回订阅列表：
[
  {
    id: 123,
    subscriptionPlanName: "FREE",
    currentCredits: 17.18,
    resetTimes: 2,
    lastCreditReset: "2025-10-17 17:25:12",
    isActive: true,
    subscriptionPlan: {
      planType: "MONTHLY",
      creditLimit: 20,
      ...
    }
  },
  ...
]
```

---

#### 第2步：过滤符合条件的订阅

```
subscriptions.filter(sub => isEligible(sub, resetType))
    ↓
对每个订阅执行6层检查：

┌─────────────────────────────────────┐
│   P0: PAYGO保护 (最高优先级)          │
│   检查4个字段：                       │
│   - subscriptionPlanName              │
│   - subscriptionPlan.subscriptionName │
│   - subscriptionPlan.planType         │
│   - subscriptionPlan.planType         │
│                                       │
│   如果是PAYGO → return false ❌      │
└─────────────────────────────────────┘
    ↓
┌─────────────────────────────────────┐
│   P1: 订阅类型检查                    │
│   planType === 'MONTHLY' ?            │
│   - Yes → 继续 ✅                    │
│   - No  → return false ❌            │
└─────────────────────────────────────┘
    ↓
┌─────────────────────────────────────┐
│   P1: 激活状态检查                    │
│   isActive === true ?                 │
│   - Yes → 继续 ✅                    │
│   - No  → return false ❌            │
└─────────────────────────────────────┘
    ↓
┌─────────────────────────────────────┐
│   P2: 冷却检查                        │
│   TimeUtils.checkCooldown()           │
│   距离上次重置 >= 5小时 ?             │
│   - Yes → 继续 ✅                    │
│   - No  → return false ❌            │
│         (记录还需等待时间)            │
└─────────────────────────────────────┘
    ↓
┌─────────────────────────────────────┐
│   P3: 重置次数检查 (关键策略)         │
│                                       │
│   if (resetType === FIRST) {          │
│       if (resetTimes < 2) {           │
│           return false ❌            │
│           // 用户已手动重置           │
│       }                               │
│       // resetTimes == 2             │
│       return true ✅                 │
│   }                                   │
│                                       │
│   if (resetType === SECOND) {         │
│       if (resetTimes < 1) {           │
│           return false ❌            │
│           // 次数已用完               │
│       }                               │
│       // resetTimes >= 1             │
│       return true ✅                 │
│   }                                   │
└─────────────────────────────────────┘
    ↓
返回符合条件的订阅列表
```

---

#### 第3步：逐个处理订阅

```
for (const subscription of eligibleSubscriptions) {
    ↓

if (resetType === SECOND) {
    ┌─────────────────────────────────────┐
    │   processSubscriptionWithDelay()     │
    │   (支持延迟重置)                     │
    └─────────────────────────────────────┘
        ↓
    ┌─────────────────────────────────────┐
    │   检查冷却状态                        │
    │   TimeUtils.checkCooldown()           │
    └─────────────────────────────────────┘
        ↓
    ┌─ 冷却已过? ─┐
    │             │
   Yes           No
    │             │
    ↓             ↓
直接重置    计算冷却结束时间
            cooldownEndTime = lastReset + 5h
                │
                ↓
        ┌─ cooldownEndTime <= 23:59:49? ─┐
        │                                 │
       Yes                               No
        │                                 │
        ↓                                 ↓
    创建延迟定时器                    放弃重置
    setTimeout(                       Logger.warn(
      执行重置,                         "今天无法完成"
      延迟毫秒数                      )
    )                                   ↓
        │                           返回SKIPPED
        ↓
    在冷却结束时触发
        ↓
    执行重置
        ↓
    返回结果

} else {
    ┌─────────────────────────────────────┐
    │   processSubscription()              │
    │   (正常处理)                         │
    └─────────────────────────────────────┘
        ↓
    记录当前状态
    - beforeCredits
    - beforeResetTimes
    - creditPercent
        ↓
    ┌─────────────────────────────────────┐
    │   APIClient.resetCredits(id)         │
    │   POST /api/reset-credits/{id}       │
    └─────────────────────────────────────┘
        ↓
    等待3秒
    (让API更新数据)
        ↓
    重新获取订阅信息
    验证重置结果
        ↓
    记录日志
    - 重置成功
    - 额度变化: X → Y
    - 次数变化: A → B
}
    ↓
每次处理后延迟1秒
(避免触发限流)
    ↓
下一个订阅...
```

---

#### 第4步：汇总结果

```
┌─────────────────────────────────────┐
│   统计结果                            │
│   - totalSubscriptions: N            │
│   - eligible: M                      │
│   - success: X                       │
│   - failed: Y                        │
│   - skipped: Z                       │
│   - totalDuration: T秒               │
└─────────────────────────────────────┘
    ↓
┌─────────────────────────────────────┐
│   记录日志                            │
│   Logger.info(                       │
│     "成功: X, 失败: Y, 跳过: Z"      │
│   )                                  │
└─────────────────────────────────────┘
    ↓
┌─────────────────────────────────────┐
│   保存历史 (可选)                    │
│   FileStorage.saveResetHistory()     │
│   → data/reset-YYYY-MM-DD.json       │
└─────────────────────────────────────┘
    ↓
返回结果对象
```

---

## 🔍 6层过滤检查详解

### 检查流程图

```
订阅对象
    ↓
┌─────────────────────────────────────┐
│ P0: PAYGO保护                        │
│ 是否为按量付费订阅？                  │
├─ Yes → ❌ 跳过 (记录警告)            │
└─ No  → ✅ 继续                       │
    ↓
┌─────────────────────────────────────┐
│ P1: 订阅类型                         │
│ planType === 'MONTHLY' ?              │
├─ No  → ❌ 跳过                       │
└─ Yes → ✅ 继续                       │
    ↓
┌─────────────────────────────────────┐
│ P1: 激活状态                         │
│ isActive === true ?                   │
├─ No  → ❌ 跳过                       │
└─ Yes → ✅ 继续                       │
    ↓
┌─────────────────────────────────────┐
│ P2: 冷却检查                         │
│ 距离上次重置 >= 5小时 ?              │
├─ No  → ❌ 跳过 (记录等待时间)        │
└─ Yes → ✅ 继续                       │
    ↓
┌─────────────────────────────────────┐
│ P3: 重置次数检查                     │
│                                       │
│ if (FIRST) {                          │
│   resetTimes == 2 ?                   │
│   ├─ No  → ❌ 跳过                   │
│   └─ Yes → ✅ 通过                   │
│ }                                     │
│                                       │
│ if (SECOND) {                         │
│   resetTimes >= 1 ?                   │
│   ├─ No  → ❌ 跳过                   │
│   └─ Yes → ✅ 通过                   │
│ }                                     │
└─────────────────────────────────────┘
    ↓
✅ 符合条件，加入待处理列表
```

---

### 检查优先级说明

| 优先级 | 检查项 | 目的 | 失败后果 |
|--------|--------|------|---------|
| **P0** | PAYGO保护 | 防止重置按量付费订阅 | 🚨 严重：可能产生费用 |
| **P1** | 订阅类型 | 只处理MONTHLY订阅 | ⚠️  中等：逻辑错误 |
| **P1** | 激活状态 | 只处理激活订阅 | ⚠️  中等：无效操作 |
| **P2** | 冷却检查 | 遵守5小时间隔规则 | ⚠️  中等：API拒绝 |
| **P3** | 次数检查 | 实现核心策略 | ℹ️  低：策略优化 |

---

## ⏰ 延迟重置逻辑详解

### 触发条件

**仅在23:56第二次重置时触发**

### 完整决策树

```
23:56 第二次重置
    ↓
检查resetTimes
    │
    ├─ < 1 → ❌ 跳过 (次数已用完)
    │
    └─ >= 1 → 继续
        ↓
    检查冷却状态
        │
        ├─ 冷却已过 (>= 5小时)
        │   ↓
        │   ✅ 直接执行重置
        │   ↓
        │   返回 SUCCESS
        │
        └─ 冷却中 (< 5小时)
            ↓
        计算冷却结束时间
        cooldownEndTime = lastCreditReset + 5小时
            ↓
        检查是否在今天内
        cooldownEndTime <= 23:59:49 ?
            │
            ├─ Yes (今天还有时间)
            │   ↓
            │   创建延迟定时器
            │   delayMs = cooldownEndTime - now
            │   ↓
            │   Logger.info(
            │     "将在 XX:XX:XX 执行延迟重置"
            │   )
            │   ↓
            │   setTimeout(() => {
            │       执行重置
            │       Logger.info("开始执行延迟重置")
            │       processSubscription()
            │   }, delayMs)
            │   ↓
            │   返回 Promise (等待延迟执行)
            │
            └─ No (会跨天)
                ↓
                Logger.warn(
                  "冷却中，今天无法完成重置"
                  "冷却结束时间: 次日 XX:XX:XX"
                )
                ↓
                返回 SKIPPED
```

---

### 时间窗口计算

```
当前时间: 23:56:00
冷却期: 5小时 = 18000000毫秒
缓冲时间: 10秒 = 10000毫秒
当天结束: 23:59:49 = 23:59:59.999 - 10000ms

示例1: 上次重置 18:59:00
  冷却结束: 18:59:00 + 5h = 23:59:00
  23:59:00 <= 23:59:49 ✅
  → 创建延迟定时器
  → 延迟时间: 23:59:00 - 23:56:00 = 3分钟

示例2: 上次重置 19:00:00
  冷却结束: 19:00:00 + 5h = 00:00:00 (次日)
  00:00:00 > 23:59:49 ❌
  → 放弃重置
  → 避免跨天
```

---

### 延迟定时器生命周期

```
创建定时器
    ↓
timerId = setTimeout(() => {
    Logger.info("开始执行延迟重置")
    ↓
    processSubscription(subscription, resetType)
    ↓
    成功:
      - Logger.success("重置成功")
      - this.delayedTimers.delete(subId)
      - resolve(result)
    ↓
    失败:
      - Logger.error("延迟重置失败")
      - this.delayedTimers.delete(subId)
      - resolve({ status: FAILED })
}, delayMs)
    ↓
this.delayedTimers.set(subId, timerId)
    ↓
等待触发...
    ↓
自动执行重置
    ↓
清理定时器
```

---

## 📊 场景分析

### 场景1: 正常无干预

```
时间线：
  00:00 resetTimes刷新为2
  08:00 用户使用20刀，余额=30
  18:55 自动重置
    - P3检查: resetTimes=2 ✅
    - 执行重置 → 余额=50, resetTimes=1
  22:00 用户使用20刀，余额=30
  23:56 自动重置
    - P2检查: 距离18:55已5小时1分 ✅
    - P3检查: resetTimes=1 ✅
    - 执行重置 → 余额=50, resetTimes=0

结果: ✅ 今天用了2次，次日开始余额=50
```

---

### 场景2: 用户13:00手动重置

```
时间线：
  00:00 resetTimes=2
  13:00 用户手动重置
    - resetTimes: 2→1
    - 余额: 某值→50
  18:55 自动检查
    - P2检查: 13:00→18:55 = 5小时55分 ✅
    - P3检查: resetTimes=1 < 2 ❌
    - 跳过 (用户已手动重置)
  23:56 自动检查
    - P2检查: 13:00→23:56 = 10小时56分 ✅
    - P3检查: resetTimes=1 ✅
    - 执行重置 → resetTimes=0

结果: ✅ 今天用了2次 (1手动+1自动)
```

---

### 场景3: 用户19:30手动重置

```
时间线：
  00:00 resetTimes=2
  18:55 自动重置
    - resetTimes: 2→1
  19:30 用户手动重置
    - resetTimes: 1→0
  23:56 自动检查
    - P2检查: 19:30→23:56 = 4小时26分 < 5小时 ❌
    - 跳过 (冷却中)

结果: ✅ 今天用了2次，避免了违反冷却规则
```

---

### 场景4: 用户18:59手动重置（延迟重置）

```
时间线：
  00:00 resetTimes=2
  18:55 自动检查
    - P3检查: resetTimes=2 ✅
    - 执行重置 → resetTimes=1
  18:59 用户手动重置
    - resetTimes: 1→0
  23:56 自动检查
    - P2检查: 18:59→23:56 = 4小时57分 < 5小时 ❌
    - 冷却中，计算冷却结束时间
    - cooldownEndTime = 18:59 + 5h = 23:59:00
    - 23:59:00 <= 23:59:49 ✅
    - 创建延迟定时器 (3分钟后)
  23:59:00 定时器触发
    - 执行延迟重置
    - Logger.info("开始执行延迟重置")

结果: ✅ 成功延迟到23:59:00执行，今天用了2次
```

---

### 场景5: 用户19:10手动重置（无法延迟）

```
时间线：
  00:00 resetTimes=2
  18:55 自动重置 → resetTimes=1
  19:10 用户手动重置 → resetTimes=0
  23:56 自动检查
    - P3检查: resetTimes=0 < 1 ❌
    - 跳过 (次数已用完)

结果: ✅ 今天用了2次，正常结束
```

---

### 场景6: 用户19:30手动重置（冷却跨天）

```
时间线：
  00:00 resetTimes=2
  18:55 自动重置 → resetTimes=1
  19:30 用户手动重置 → resetTimes=0
  23:56 自动检查
    - P3检查: resetTimes=0 < 1 ❌
    - 跳过

OR (假设resetTimes还有1次):
  23:56 自动检查
    - P2检查: 19:30→23:56 = 4小时26分 < 5小时 ❌
    - 冷却中
    - cooldownEndTime = 19:30 + 5h = 00:30 (次日)
    - 00:30 > 23:59:49 ❌
    - Logger.warn("冷却中，今天无法完成重置")
    - 放弃 (避免跨天占用次日次数)

结果: ✅ 正常放弃，不跨天
```

---

## 🌲 决策树

### 18:55 首次重置决策树

```
订阅对象
    │
    ├─ 是PAYGO? ──Yes──> ❌ 跳过
    │      No
    ├─ 非MONTHLY? ──Yes──> ❌ 跳过
    │      No
    ├─ 未激活? ──Yes──> ❌ 跳过
    │      No
    ├─ 冷却未过? ──Yes──> ❌ 跳过
    │      No
    ├─ resetTimes < 2? ──Yes──> ❌ 跳过 (用户已手动重置)
    │      No
    └─ resetTimes == 2 ──────> ✅ 无脑重置
                              理由: 确保用完2次机会
```

---

### 23:56 二次重置决策树（含延迟）

```
订阅对象
    │
    ├─ 是PAYGO? ──Yes──> ❌ 跳过
    │      No
    ├─ 非MONTHLY? ──Yes──> ❌ 跳过
    │      No
    ├─ 未激活? ──Yes──> ❌ 跳过
    │      No
    ├─ resetTimes < 1? ──Yes──> ❌ 跳过 (次数已用完)
    │      No
    └─ resetTimes >= 1
           │
           ├─ 冷却已过? ──Yes──> ✅ 直接重置
           │      No
           └─ 冷却中
               │
               计算冷却结束时间 = lastReset + 5小时
               │
               ├─ 结束时间 <= 23:59:49? ──Yes──> ⏰ 创建延迟定时器
               │                                     在冷却结束时重置
               │                                     ✅ 延迟重置
               │
               └─ 结束时间 > 23:59:49 ──────────> ❌ 放弃
                                                   会跨天，避免浪费次日次数
```

---

## 🔄 状态机

### 订阅重置状态机

```
                    ┌─────────────┐
                    │   PENDING   │
                    │  (待处理)    │
                    └──────┬──────┘
                           │
                ┌──────────┴──────────┐
                │   开始处理           │
                └──────────┬──────────┘
                           │
                    ┌──────▼──────┐
                    │  CHECKING   │
                    │  (检查中)    │
                    └──────┬──────┘
                           │
        ┌──────────────────┼──────────────────┐
        │                  │                  │
        ▼                  ▼                  ▼
  ┌──────────┐      ┌───────────┐     ┌──────────┐
  │ SKIPPED  │      │ COOLDOWN  │     │ ELIGIBLE │
  │  (跳过)  │      │  (冷却中)  │     │ (符合)   │
  └──────────┘      └─────┬─────┘     └────┬─────┘
        │                 │                 │
        │           ┌─────┴─────┐           │
        │           │           │           │
        │           ▼           ▼           │
        │     ┌───────────┐  ┌──────────┐  │
        │     │ DELAYED   │  │ REJECTED │  │
        │     │  (延迟)    │  │ (拒绝)   │  │
        │     └─────┬─────┘  └──────────┘  │
        │           │                       │
        │           └───────┐       ┌───────┘
        │                   │       │
        │                   ▼       ▼
        │            ┌───────────────────┐
        │            │   PROCESSING      │
        │            │   (处理中)         │
        │            └─────────┬─────────┘
        │                      │
        │          ┌───────────┼───────────┐
        │          │           │           │
        │          ▼           ▼           ▼
        │    ┌─────────┐ ┌─────────┐ ┌─────────┐
        │    │SUCCESS  │ │ FAILED  │ │ PARTIAL │
        │    │ (成功)  │ │ (失败)  │ │ (部分)  │
        │    └─────────┘ └─────────┘ └─────────┘
        │          │           │           │
        └──────────┴───────────┴───────────┘
                       │
                       ▼
                 ┌──────────┐
                 │ COMPLETED│
                 │  (完成)  │
                 └──────────┘
```

---

### 状态转换说明

| 起始状态 | 触发条件 | 目标状态 | 说明 |
|---------|---------|---------|------|
| PENDING | 开始检查 | CHECKING | 进入6层检查 |
| CHECKING | 不符合P0-P3 | SKIPPED | 跳过处理 |
| CHECKING | 冷却中且能延迟 | COOLDOWN→DELAYED | 创建延迟定时器 |
| CHECKING | 冷却中且会跨天 | COOLDOWN→REJECTED | 放弃处理 |
| CHECKING | 所有检查通过 | ELIGIBLE | 符合条件 |
| ELIGIBLE | 开始重置 | PROCESSING | 执行重置API |
| DELAYED | 定时器触发 | PROCESSING | 执行延迟重置 |
| PROCESSING | API成功 | SUCCESS | 重置成功 |
| PROCESSING | API失败 | FAILED | 重置失败 |
| PROCESSING | 部分成功 | PARTIAL | 部分操作成功 |
| * | 结束 | COMPLETED | 流程完成 |

---

## ✅ 总结

### 核心逻辑特点

1. **无脑重置策略**
   - 18:55: resetTimes==2 就重置
   - 23:56: resetTimes>=1 就重置
   - 目标: 确保每天用完2次

2. **智能延迟重置**
   - 仅在23:56触发
   - 检查冷却结束时间
   - 如果在23:59:49前，创建延迟定时器
   - 如果会跨天，放弃（避免占用次日次数）

3. **6层过滤保护**
   - P0: PAYGO保护（最高优先级）
   - P1: 类型和状态检查
   - P2: 冷却检查（5小时）
   - P3: 次数检查（核心策略）

4. **完善的容错机制**
   - 网络层: 速率限制 + 重试
   - 业务层: 串行处理 + 异常隔离
   - 调度层: 执行锁 + 优雅关闭

### 设计优势

- ✅ 逻辑清晰 - 分层明确，职责分离
- ✅ 容错完善 - 多层保护，自动恢复
- ✅ 策略最优 - 确保每天用完2次机会
- ✅ 日志详细 - 完整记录每个步骤
- ✅ 易于维护 - 模块化设计，代码规范

---

**完整逻辑文档 v1.0** ✅
